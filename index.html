<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Antarctica_32x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/Antarctica_16x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Wuthering Heights Dumb house">
<meta property="og:type" content="website">
<meta property="og:title" content="呼啸山庄的哑舍">
<meta property="og:url" content="http://www.ytalyq.top/index.html">
<meta property="og:site_name" content="呼啸山庄的哑舍">
<meta property="og:description" content="Wuthering Heights Dumb house">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="呼啸山庄的哑舍">
<meta name="twitter:description" content="Wuthering Heights Dumb house">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.ytalyq.top/">





  <title>呼啸山庄的哑舍</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">呼啸山庄的哑舍</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">要是一开始只选择自己能做到的事情，那么就永远无法前进。重要的是你自身有没有兴趣不是吗？</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ytalyq.top/2020/04/18/网络通信协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清衍之">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyz.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="呼啸山庄的哑舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/18/网络通信协议/" itemprop="url">网络通信协议_TCP、IP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-18T17:20:13+08:00">
                2020-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络通信协议-TCP、IP协议"><a href="#网络通信协议-TCP、IP协议" class="headerlink" title="网络通信协议_TCP、IP协议"></a>网络通信协议_TCP、IP协议</h1><h2 id="了解网络协议的概念"><a href="#了解网络协议的概念" class="headerlink" title="了解网络协议的概念"></a>了解网络协议的概念</h2><ul>
<li><p>网络协议:计算机网络和分布式系统中互相通信的对等实体(军长对军长统一)之间交换信息时必须遵循的规则的集合</p>
</li>
<li><p>SAP (server access point)服务访问点 同一个层次系统上下层进行通信的接口</p>
</li>
</ul>
<h2 id="了解网络体系结构："><a href="#了解网络体系结构：" class="headerlink" title="了解网络体系结构："></a>了解网络体系结构：</h2><ul>
<li>指通信系统整体设计方法，是计算机之间相互通信的层次、以及各层中的协议和层次之间接口的集合，它为网络硬件、软件、协议、存取控制和网络拓扑提供标准</li>
<li>SNA：IBM公司开发适合自己公司的网络体系结构(System Network Architecture)</li>
<li>DNA: DEC公司开  发适合自己公司的网络体系结构(Date Network Architecture)</li>
<li>OSI/RM:由ISO(国际标准化组织)统一规定的互联网参考模型(Open Standard Interconnection/Reference Model)开放系统互连参考模型</li>
<li><p>计算机网络协议</p>
<ul>
<li>负责在网络上建立通信通道和控制通过通道的信息流的规则。</li>
<li>协议依赖于网络体系结构，由硬件软件协同实现。</li>
</ul>
</li>
<li><p>计算机网络协议的组成</p>
<ul>
<li>语法：(侧重怎么描述信息 类似语文英语的语法) 用于确认协议元素的格式，即数据与控制信息的结构和格式。</li>
<li>语义：(突出传输的信息是什么) 用于确认协议元素的类型，即规定了通信双方需要发出何种控制信息，完成何种动作，以及做出何种应答。</li>
<li>定时：(遵循一定的时间规则要求)用于确定通信速度的匹配和时序，即对事件实现顺序的详细说明。</li>
</ul>
</li>
</ul>
<h2 id="熟悉ISO-OSI参考模型各层主要协议及其功能"><a href="#熟悉ISO-OSI参考模型各层主要协议及其功能" class="headerlink" title="熟悉ISO/OSI参考模型各层主要协议及其功能"></a>熟悉ISO/OSI参考模型各层主要协议及其功能</h2><ul>
<li><p>应用层：(DNS)</p>
<pre><code>提供应用程序运行的环境、负责管理和执行应用程序
</code></pre></li>
<li><p>表示层：</p>
<pre><code>为数据在传输之前对加密、解密、压缩、解压缩及终端数据格式转换提供一套规则和约定
</code></pre></li>
<li>会话层：<pre><code>对对话的双方进行资格审查和验证的规则，同时规定发送时的双工模式(电话就是双工)。
</code></pre></li>
</ul>
<hr>
<ul>
<li>网络层： (IP  路由器 交换机)<pre><code>负责建立、保持和终止通过中间设备的连接，同时负责通信子网内路径选择和拥挤控制  
</code></pre></li>
<li>数据链路层：(Frame   以太网   )<pre><code> 主要功能有如何将数据组装成帧，帧是本层的传输单位，如何处理数据在传输过程中出现的差错，
如何调节发送速率使之与接受方匹配，在两个网络实体之间提供数据链路的建立、维持和释放管理
</code></pre></li>
<li>物理层： (网卡接口  )<pre><code>包括设备之间物理连接的接口和用户设备与网络终端设备之间的传输规则
物理层有四个重要特性：
    机械特性:  规定了物理连接时对插头和插座的几何尺寸、插针或插孔芯数及排列方式
    电气特性： 规定了信号状态的电压、电流的识别，最大传输速率等
    功能特性： 规定接口信号的来源、作用及其他信号之间的关系
    过程特性： 规定了使用交换电路进行数据交换控制步骤，这些控制步骤应用便于比特流传输得以顺利完成
</code></pre></li>
</ul>
<h2 id="OSI七层模型工作过程"><a href="#OSI七层模型工作过程" class="headerlink" title="OSI七层模型工作过程"></a>OSI七层模型工作过程</h2><ul>
<li>应用层：是应用程序访问网络服务的窗口</li>
<li>表示层：确定计算机之间交换数据的格式(格式转换 压缩  加密 解密 ..)</li>
<li>会话层：允许不同计算机上的两个应用程序建立、使用和结束会话连接</li>
<li>传输层：确保报文无差错、有序、不丢失、无重复的传输<pre><code>基本功能  分割数据与重组数据、按端口号寻址、连接管理、差错控制和流量控制
</code></pre></li>
<li>网络层：负责信息寻址和将逻辑地址和名字转换为物理地址</li>
<li>数据链路层：负责从网络层向物理层发送数据帧</li>
<li>物理层：建立在通信介质基础上的，实现设备之间的物理接口</li>
<li>总结：<br>应用层：—&gt;为应用程序提供网络服务(用户接口)<br>表示层：—&gt;数据表示<br>会话层：—&gt;互联主机通信维持不同应用程序的数据分割<br>传输层：—&gt;端到端连接，提供可靠或者不可靠数据传输<br>网络层：—&gt;确定地址和最佳路径(逻辑寻址)<br>数据链路层：—&gt;介质访问(将数据包组合为字节)<br>物理层：—&gt;二进制传输</li>
</ul>
<h2 id="OSI七层模型的使用"><a href="#OSI七层模型的使用" class="headerlink" title="OSI七层模型的使用"></a>OSI七层模型的使用</h2><ul>
<li>计算机1向计算机2发送数据<br>765–[应用层 表示层 会话层]应用进程数据先传送到应用层–加上应用层首部，成为应用层PDU(协议数据单元)  应用层PDU再传输到运输层<br> 4–[传输层] 加上运输层首部，成为运输层报文  传送到网路层<br> 3–[网络层] 加上网络层首部，成为IP数据报(或分组)  传输到数据链路层<br> 2–[数据链路层]  加上数据链路层首部和尾部，成为数据链路层帧  传送到物理层<br> 1–[物理层]  把比特流传送到物理媒体   电信号(或光信号) 在物理媒体中传播从发送端物理层传送到接受端物理层</li>
<li>反之向上一层层剥离数据首部</li>
</ul>
<h2 id="TCP-IP模型各层的主要协议及其功能-4层"><a href="#TCP-IP模型各层的主要协议及其功能-4层" class="headerlink" title="TCP/IP模型各层的主要协议及其功能  4层"></a>TCP/IP模型各层的主要协议及其功能  4层</h2><ul>
<li>PDU : 对等层之间传递的数据单位</li>
<li>APDU–PPDU–SPDU–Segment–Packet–Frame–Bit  [application  presentation session ]</li>
<li>TCP/IP :应用层  传输层  网络层  网络接口层</li>
<li>目的：解决异种计算机网络通信的问题</li>
<li>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。</li>
<li>TCP/IP协议能够迅速发展起来并成为事实上的标准，是它恰好适应了世界范围内数据通信的需要。它有以下特点：<ol>
<li>协议标准是完全开放的，可以供用户免费使用，并且独立于特定的计算机硬件与操作系统。</li>
<li>独立于网络硬件系统，可以运行在广域网，更适合于互联网。</li>
<li>网络地址统一分配，网络中每一设备和终端都具有一个唯一地址。</li>
<li>高层协议标准化，可以提供多种多样可靠网络服务。</li>
</ol>
</li>
<li>应用层：<ul>
<li>FTP     文件传输协议</li>
<li>TELNET  终端仿真    远程</li>
<li>DNS     域名–&gt;互联网地址</li>
</ul>
</li>
<li>传输层：<ul>
<li>TCP   Transmission Control Protocol         传输控制协议　　             [可靠流服务 面向连接]</li>
<li>UDP   User Datagram Protocol                用户数据报协议</li>
</ul>
</li>
<li>网络层: <ul>
<li>IP:   Internet Protocol                     互联网报文协议                 [数据报服务]</li>
<li>ICMP: Internet Control Message Protocol     互联网控制报文协议             [差错和控制]</li>
<li>ARP:  Address Resolution Protocol           地址解析协议                [互联网地址–&gt;物理地址]</li>
<li>RARP: Reverse Address Resolution Protocol   反向地址解析协议         [物理地址–&gt;互联网地址]</li>
</ul>
</li>
<li>网络接口层:</li>
</ul>
<h2 id="TCP-IP的基本工作原理"><a href="#TCP-IP的基本工作原理" class="headerlink" title="TCP/IP的基本工作原理"></a>TCP/IP的基本工作原理</h2><ul>
<li>TCP/IP的文件传输(FTP)封装<br>—-以太帧头   目的地址   源地址   包类型    包数据      CRC<br>—-以太帧头    IP头      TCP头         FTP头     IP数据报         </li>
</ul>
<h2 id="网络接口层详解"><a href="#网络接口层详解" class="headerlink" title="网络接口层详解"></a>网络接口层详解</h2><ul>
<li>IEEE:      Institute of Electrical and Electronics Engineers</li>
<li>IEEE802标准：涉及对象为OSI七层模型中的数据链路层和物理层<br>上述思想把OSI数据链路层分为两个部分<ol>
<li>LLC：逻辑链路控制        功能–连接管理(建立和释放链接)，与高层的接口，帧的可靠，按序传输及流量控制<br>四种数据操作类型：<pre><code>a.不确定的无连接服务        [发送广播数据包]
b.面向连接的服务            [传输数据文件  需要确认]
c.带确认的无连接服务        [控制信号   报警信息]
d.高速传送的服务
</code></pre></li>
<li>MAC：介质访问控制层    功能–帧的封装和拆分，物理介质传输差错的检测，寻址，实现介质访问控制协议</li>
</ol>
</li>
</ul>
<ol start="3">
<li>MAC决定对传输介质的访问控制分为3种方式<pre><code>循环式：每个站点轮流得到发送数据的机会
预约式：在传输数据时需要预约资源
竞争式：按照先到先得的原则发送数据，抢占网络传输资源
</code></pre></li>
</ol>
<ul>
<li>//802.3:  CSMA/CD–载波侦听多路访问/冲突检测<br>//802.4    TOKEN BUS–令牌总线协议<br>//802.5： ToKEN RING–令牌环线协议</li>
<li>局域网使用网络接口层协议代表<ul>
<li>以太网</li>
</ul>
</li>
<li>令牌环线协议<ul>
<li>FDDI</li>
</ul>
</li>
<li>广域网使用网络接口层协议代表<ul>
<li>SLIP  串行线路网际协议</li>
<li>PPP   点对点协议，MTU默认1500字节</li>
</ul>
</li>
</ul>
<h2 id="网络层IP协议详解"><a href="#网络层IP协议详解" class="headerlink" title="网络层IP协议详解"></a>网络层IP协议详解</h2><ul>
<li><p>IP协议功能</p>
<ol>
<li>寻址 和 路由</li>
<li><p>传递服务</p>
</li>
<li><p>不可靠，可靠星由上层协议提供</p>
</li>
<li><p>无连接</p>
</li>
<li><p>数据报分段和重组</p>
</li>
</ol>
</li>
</ul>
<h2 id="网络层IP协议详解2"><a href="#网络层IP协议详解2" class="headerlink" title="网络层IP协议详解2"></a>网络层IP协议详解2</h2><ul>
<li><a href="https://baike.baidu.com/item/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/1581132?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/1581132?fr=aladdin</a>  </li>
<li>首部长度是指版本～可选之间的字段        </li>
<li>最大值：版本(4位)+首部长度(4位)+服务类型(8位)+总长度(16位)+标识(16位)+标志(3位)+片偏移量(13位)+生存时间(8位)+上层协议(8位)+首部校验和(16位)+源地址(32位)+目的地址(32位)+可选项(最大字节为40，则得出320位)=480位/8=60字节</li>
<li>版本：占4位，指IP协议的版本。通信双方使用的IP协议版本必须一致。</li>
<li>首部长度：占4位，可表示的最大十进制数值是15。这个字段所表示数的单位是32位字长 (4字节)  15*4=60</li>
<li>区分服务：占8位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过</li>
<li>总长度：首部和数据之和的长度，单位为字节。总长度字段为16位，因此数据报的最大长度为2^16-1=65535字节。</li>
<li>标识(identification)：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。</li>
<li>标志(flag)：占3位，但只有2位有意义 详细见百度 null  DF  MF</li>
<li>片偏移：占13位 以8个字节为偏移单位  <a href="https://zhidao.baidu.com/question/40279160.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/40279160.html</a></li>
<li>生存时间：占8位，生存时间英文缩写是TTL(Time To Live) 目的是防止无法交付的数据报无限制地在因特网中兜圈子</li>
<li>协议：占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程</li>
<li>首部检验和：占16位  这个字段只检验数据报的首部，但不包括数据部分</li>
<li>源地址：占32位</li>
<li>目的地址：占32位</li>
<li>IP数据报首部可变部分  了解<br>增加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用</li>
<li>数据部分</li>
</ul>
<h2 id="IP地址和MAC地址特征分析"><a href="#IP地址和MAC地址特征分析" class="headerlink" title="IP地址和MAC地址特征分析"></a>IP地址和MAC地址特征分析</h2><ul>
<li><p>ARP        地址解析协议</p>
<ul>
<li><p>逻辑地址：</p>
<ul>
<li>工作在网络层</li>
<li><p>全局唯一性        公网IP地址不能冲突</p>
</li>
<li><p>用软件实现的网络地址管理</p>
</li>
<li><p>二进制为32位  正常以十进制显示</p>
</li>
</ul>
</li>
<li><p>物理地址：</p>
<ul>
<li>(硬件地址 MAC地址  链路地址)  工作在网络接口层</li>
<li><p>本地范围生效 唯一</p>
</li>
<li><p>用硬件实现</p>
</li>
<li><p>二进制为48位   正常以十六进制表示</p>
</li>
<li><p>MAC地址固化在网卡的ROM中</p>
</li>
<li><p>32位IP地址 ——-ARP——&gt;48位以太网地址</p>
</li>
<li>32位IP地址&lt;——-RARP——48位以太网地址</li>
</ul>
</li>
</ul>
</li>
<li>有IP地址为什么还使用MAC地址？<ol>
<li>IP地址一般情况容易修改和变动，具有随意性，不能在网络上固定标识一台设备</li>
<li>MAC地址一般情况出厂时由厂家烧录到硬件，不容易修改，在局域范围内容易定位唯一一台设备</li>
<li>从拓扑结构和分层上分析，IP地址属于网络层部分，主要功能是在广域网范围内路由寻址，选择最佳路由 而MAC地址在网络接口层要形成适用于在网络媒体上传输的数据帧。</li>
</ol>
</li>
</ul>
<h2 id="ARP工作过程及工作原理解析"><a href="#ARP工作过程及工作原理解析" class="headerlink" title="ARP工作过程及工作原理解析"></a>ARP工作过程及工作原理解析</h2><ul>
<li>主机A通过  ARP协议发送广播请求获得目标主机B的MAC地址  由于路由器做中间商  路由器将它的MAC地址提供给A 一样传递信息   B接收到A的请求后 单向传输信息给A</li>
<li>ARP：根据IP地址获取物理地址的一个TCP/IP协议。<a href="https://baike.baidu.com/item/ARP/609343" target="_blank" rel="noopener">https://baike.baidu.com/item/ARP/609343</a> </li>
<li>不管网络层使用的什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址<br>每个主机都设有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器的IP地址到硬件地址的映射表</li>
<li>当想要发送IP数据报时，先在缓存查看　有就加载没有重新写入</li>
</ul>
<h2 id="ARP分组封装格式及RARP解析"><a href="#ARP分组封装格式及RARP解析" class="headerlink" title="ARP分组封装格式及RARP解析"></a>ARP分组封装格式及RARP解析</h2><ul>
<li><p>ARP数据包</p>
<ul>
<li><p>硬件类型    16位</p>
</li>
<li><p>协议类型    16位</p>
</li>
<li><p>硬件长度    8位</p>
</li>
<li><p>协议长度    8位</p>
</li>
<li><p>操作  请求1  回答2    16位</p>
</li>
<li><p>发送方硬件地址        6字节</p>
</li>
<li><p>发送方IP地址        4字节</p>
</li>
<li><p>目标方硬件地址        6字节</p>
</li>
<li>目标方IP地址        4字节</li>
</ul>
</li>
<li>RARP<ul>
<li>RARP使只知道自己硬件地址的主机能够知道其IP地址        RARP很少用到</li>
</ul>
</li>
</ul>
<h2 id="ICMP基础知识解析-互联网控制消息协议"><a href="#ICMP基础知识解析-互联网控制消息协议" class="headerlink" title="ICMP基础知识解析 (互联网控制消息协议)"></a>ICMP基础知识解析 (互联网控制消息协议)</h2><ul>
<li><p>IP缺点:</p>
<ul>
<li><p>无差错报告和差错纠正机制</p>
</li>
<li><p>缺少一种为主机和管理查询的机制</p>
</li>
</ul>
</li>
<li>TTL：每经过一个路由就会减少一个跳数  跳数为0 会丢弃数据包</li>
<li>ICMP报文首先封装成IP数据报然后传给下一层</li>
<li>IP数据报中的协议字段是1 表示IP数据是ICMP报文</li>
</ul>
<h2 id="ICMP报文分类和报文结构解析"><a href="#ICMP报文分类和报文结构解析" class="headerlink" title="ICMP报文分类和报文结构解析"></a>ICMP报文分类和报文结构解析</h2><ul>
<li>ICMP报文种类        <a href="https://blog.csdn.net/qq_35733751/article/details/80043941" target="_blank" rel="noopener">https://blog.csdn.net/qq_35733751/article/details/80043941</a><ol>
<li>差错报告报文：ICMP总是把差错报文报告给原始的数据源<pre><code>类型3：终点不可达    当数据包不能发送到目标主机或路由时，就会丢弃该数据包向源点发送终点不可达报文
类型4：源点抑制        数据在传输过程中，如果源点发送数据很快，而目的地接收数据慢，造成拥塞，这时就会向源点发送源点抑制报文，告知源点应该降低发送数据包的速率。
类型11：超时        路由器收到TTL值为0的数据包时，会丢弃该数据包并向源点发送超时报文  也有可能数据分片在进行重组超过规定时间也会丢弃已收到的报文然后向源点发送超时报文
类型12：参数问题    可能是IP首部有的字段值是错误的或者IP首部被修改，破坏都有可能，因为IP数据报文有一个首部校验和的字段会对IP首部进行校验。
类型5：改变路由(路由重定向)Redict
                    主机A在给主机B发送数据时，数据在传输过程中选择的传输路线不是最优的，这时主机B会发送一个改变路由的ICMP数据报文告知主机A下次发送数据时选择另外的路线
</code></pre></li>
<li>查询报文<pre><code>类型8或0：回送(Echo)请求或回答        
类型13或14：时间戳(Timestamp)请求或回答    
类型17或18：地址码请求或回答
类型10或9：路由器查询通过
</code></pre></li>
</ol>
</li>
<li>以下几种情况都不会导致产生ICMP差错报文<ol>
<li>已经携带ICMP差错报文的数据报（但是，ICMP查询报文可能会产生ICMP差错报文）</li>
<li>具有多播地址的数据报        部分主机可以收到   224.0.0.0-239.255.255.255这个范围不会产生</li>
<li>作为链路层广播的数据报</li>
<li>不是IP分片的第一片的数据报</li>
<li>具有特殊地址的数据报        127.0.0.0 回环</li>
</ol>
</li>
<li><p>ICMP 差错报文</p>
<ul>
<li>终点不可达差错报告解析<ul>
<li>0 0 Echo Reply——回显应答（Ping应答） x</li>
<li>3 0 Network Unreachable——网络不可达 x    R</li>
<li>3 1 Host Unreachable——主机不可达 x        R</li>
<li>3 2 Protocol Unreachable——协议不可达 x    PC</li>
<li>3 3 Port Unreachable——端口不可达 x        PC</li>
<li>3 4 Fragmentation needed but no frag. bit set——需要进行分片但设置不分片比特 x        R</li>
<li>3 5 Source routing failed——源站选路失败 x</li>
<li>3 6 Destination network unknown——目的网络未知 x</li>
<li>3 7 Destination host unknown——目的主机未知 x</li>
<li>3 8 Source host isolated (obsolete)——源主机被隔离（作废不用） x</li>
<li>3 9 Destination network administratively prohibited——目的网络被强制禁止 x</li>
<li>3 10 Destination host administratively prohibited——目的主机被强制禁止 x</li>
<li>3 11 Network unreachable for TOS——由于服务类型TOS，网络不可达 x</li>
<li>3 12 Host unreachable for TOS——由于服务类型TOS，主机不可达 x</li>
<li>3 13 Communication administratively prohibited by filtering——由于过滤，通信被强制禁止 x</li>
<li>3 14 Host precedence violation——主机越权 x</li>
<li>3 15 Precedence cutoff in effect——优先中止生效 x</li>
</ul>
</li>
<li><p>源点抑制差错报告解析        IP协议是无连接协议，没有流量控制机制，容易产生拥塞。这报文通知源点数据报因拥塞已丢失   警告源点路径拥塞  抑制发送速度</p>
<ul>
<li>4 0 Source quench——源端被关闭（基本流控制）</li>
</ul>
</li>
<li>改变路由差错报告解析<ul>
<li>5 0 Redirect for network——对网络重定向        对网络路由的改变</li>
<li>5 1 Redirect for host——对主机重定向    </li>
<li>5 2 Redirect for TOS and network——对服务类型和网络重定向</li>
<li>5 3 Redirect for TOS and host——对服务类型和主机重定向</li>
</ul>
</li>
<li>超时差错报告解析<ul>
<li>11 0 TTL equals 0 during transit——传输期间生存时间为0 TTL为0 x                R</li>
<li>11 1 TTL equals 0 during reassembly——在数据报组装期间不是所有分片都到达了生存时间为0 x    PC</li>
</ul>
</li>
<li>参数差错报告解析<ul>
<li>12 0 IP header bad (catchall error)——坏的IP首部（包括各种差错） x</li>
<li>12 1 Required options missing——缺少必需的选项 x</li>
</ul>
</li>
</ul>
</li>
<li>ICMP查询报文<ul>
<li>回送请求和回送应答<ul>
<li>8 0 Echo request——回显请求（Ping请求） x</li>
</ul>
</li>
<li>路由器询问和通告<ul>
<li>9 0 Router advertisement——路由器通告</li>
<li>10 0 Route solicitation——路由器请求</li>
</ul>
</li>
<li>时间戳请求和回答<ul>
<li>13 0 Timestamp request (obsolete)——时间戳请求（作废不用） x</li>
<li>14 Timestamp reply (obsolete)——时间戳应答（作废不用） x    </li>
</ul>
</li>
<li>信息请求和回答<ul>
<li>15 0 Information request (obsolete)——信息请求（作废不用） x</li>
<li>16 0 Information reply (obsolete)——信息应答（作废不用） x</li>
</ul>
</li>
<li>地址掩码请求和回答<ul>
<li>17 0 Address mask request——地址掩码请求 x</li>
<li>18 0 Address mask reply——地址掩码应答</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Ping-amp-traceroute命令的使用"><a href="#Ping-amp-traceroute命令的使用" class="headerlink" title="Ping&amp;traceroute命令的使用"></a>Ping&amp;traceroute命令的使用</h2><ul>
<li>排错工具</li>
<li>ping：发送回显信息<ul>
<li>ping -l    字节数  地址        ping指定字节的地址</li>
<li>ping -t    地址    一直发送</li>
</ul>
</li>
<li>tracert：路由跟踪        (Linux用 traceroute)<ul>
<li>源主机从ttl值为1开始发送icmp报文，每次三回合，ttl值每次重新发送都加1 直到能发送到目标主机  发送给目标主机也是三回合</li>
</ul>
</li>
</ul>
<h2 id="传输层-TCP协议详解"><a href="#传输层-TCP协议详解" class="headerlink" title="传输层-TCP协议详解"></a>传输层-TCP协议详解</h2><ul>
<li>分段及封装应用层传来的数据</li>
<li><p>分段：</p>
<ul>
<li>每个从应用层到传输层的字节都有一个编号    字节号    </li>
<li><p>字节在传输层组成段后 有一个序号        序号为首个字节的</p>
</li>
<li><p>每个西瓜编号    西瓜放一车    车有序号</p>
</li>
<li><p>封装：封装传输层的首部数据    端口号(门牌号)</p>
</li>
</ul>
</li>
<li>提供端到端的传输服务</li>
<li>宏观上端到端(端口到端口)    微观上通过一系列IP层传输</li>
<li>在发送主机和接受主机之间构建逻辑通信<ul>
<li>包括两个协议<br>TCP<br> UDP </li>
</ul>
</li>
<li><p>两台主机进程通信条件</p>
<ul>
<li>本地主机(IP地址定义)</li>
<li><p>本地进程(端口定义)</p>
</li>
<li><p>远程主机(IP地址定义)</p>
</li>
<li><p>远程进程(端口定义)</p>
</li>
</ul>
</li>
<li><p>端口范围</p>
<ul>
<li><p>熟知端口：0-1023，ICANN指派和控制    FTP控制连接21    FTP数据连接:20    TELNET:23    DNS:53    HTTP:80</p>
</li>
<li><p>注册端口：1024-49151，IANA不指派不控制，须注册</p>
</li>
<li>动态端口：49152-65535    不指派不控制，不注册</li>
</ul>
</li>
<li><p>传输层分用和复用</p>
<ul>
<li>通过端口号区分进程</li>
<li><p>发送方复用        接收方分用</p>
</li>
<li><p>TCP报文段给网络层    UDP用户数据报给网络层</p>
</li>
</ul>
</li>
<li>总结：应用程序产生应用进程，应用进程产生进程端口号，进程端口提供应用服务</li>
</ul>
<h2 id="TCP发送缓存、接收缓存及报文段详解"><a href="#TCP发送缓存、接收缓存及报文段详解" class="headerlink" title="TCP发送缓存、接收缓存及报文段详解"></a>TCP发送缓存、接收缓存及报文段详解</h2><ul>
<li>面向连接的服务<ul>
<li>通讯双方交换数据之前必须建立连接</li>
</ul>
</li>
<li>可靠的<ul>
<li>多种确保可靠性的机制</li>
</ul>
</li>
<li>字节流服务<ul>
<li>8bit(1Byte)为最小单位构成的字节流</li>
</ul>
</li>
<li>套接字地址    IP地址+端口号<ul>
<li>TCP使用“连接“(而不仅仅时”端口”)作为最基本的对象，同时将TCP连接的端点称为插口(socket),或套接字、套接口<pre><code>插口和端口、IP地址的关系是：192.168.0.1：8080 = socket
</code></pre></li>
</ul>
</li>
<li>发送端[应用进程]—&gt;端口—TCP[发送缓存]—&gt;<ol>
<li>TCP发送进程以字节流的形式传递数据，而接收进程也把数据作为字节流来接收，类似于假想的管道</li>
<li>UDP发送进程的数据报文都是独立的，因此UDP不是面向流的协议</li>
<li>缓存：数据流向的每一个方向上都有两种缓存：发送缓存、接收缓存</li>
<li>传输层向IP层发送数据时要以分组为单位，而不是按字节流来发送，TCP协议把若干字节构成一个分组，可以把分组称为报文段(segment),</li>
<li>这种报文段并不一定都一样长，可以几个字节也可以是几千字节</li>
</ol>
</li>
</ul>
<h2 id="TCP中的字节号和序号详解"><a href="#TCP中的字节号和序号详解" class="headerlink" title="TCP中的字节号和序号详解"></a>TCP中的字节号和序号详解</h2><ul>
<li><p>字节号：</p>
<ul>
<li><p>以字节为单位</p>
</li>
<li><p>字节号的定义范围(0~2^32-1)</p>
</li>
<li><p>编号机制：随机</p>
</li>
<li><p>举例：随机号为1057，要发送6000字节，字节编号范围为：1057~7056</p>
</li>
</ul>
</li>
<li><p>序号：</p>
<ul>
<li><p>以字节为基础，TCP给每个报文段指派一个序号</p>
</li>
<li><p>每个报文段的序号就是在这个报文段中的第一个字节数据的序号</p>
</li>
<li><p>举例:</p>
<pre><code>TCP要传输6000个字节的文件。第一个字节的编号为10001     如果数据以5个报文段发送，前四个各携带1000
</code></pre><p>   最后的携带2000字节的数据<br>   报文段1 (10001-11000)        序号为首个字节<br>   报文段2 (11001-12000)<br>   报文段3 (12001-13000)<br>   报文段4 (13001-14000)<br>   报文段5 (14001-16000)</p>
</li>
</ul>
</li>
</ul>
<h2 id="TCP中的报文段格式详解"><a href="#TCP中的报文段格式详解" class="headerlink" title="TCP中的报文段格式详解"></a>TCP中的报文段格式详解</h2><ul>
<li>源端口(2字节)：发送端应用程序的端口号，与源IP地址确定一个唯一地址</li>
<li>目的端口（2字节）：接收端计算机应用程序的端口号，与目的IP地址确定唯一的地址</li>
<li>序号（4字节）：TCP是面向字节流传输的，他为每一个字节编了一个序号，该报文段中序号为传输数据第一个字节的序号，例如：一个报文端的数据部分大小为100个字节，他的序号为400，那么下一次报文段的序号就为500</li>
<li>确认号（4个字节）：指明了下一个期待接收的字节序号，表明该序号之前的所有字节都正确接收到了，只有当ACK为1的时候确认号才有效</li>
<li>数据偏移/首部长度（4个字节）： 用来表示报文段数据的起始处距离报文起始处的长度也就是TCP报文首部的长度，由于首部含有可选项，所以TCP报头长度是不确定的。</li>
<li>保留：为了将来定义新的用途保留，现在一般都置为0</li>
<li>URG紧急控制位：与紧急指针配合使用，当URG为1的时候，就是通知系统这个报文段有紧急数据，需要优先传输。</li>
<li>ACK确认控制位: 当他为1的时候，确认号字段才有效，TCP规定，在连接建立后，所有ACK都应该置为1</li>
<li>PSH推送控制位：当报文段的psh为1的时候，接收方接到该报文段，就立刻将他交付给接收应用进程，而不是等缓存已满的时候再交付。</li>
<li>RST复位控制位: 当RST = 1 时，表明TCP连接出现严重错误，必须释放连接，然后在重新建立运输连接    <ul>
<li>三种情况下出现<br>1.拒绝连接请求        接收方未开启发送方需要的端口号<br>2.异常的终止连接<br>3.终止空闲连接</li>
</ul>
</li>
<li>SYN同步控制位：在连接建立时用来同步序列号，当SYN=1,ACK=0时说明这是一个连接请求报文段，如果对方同意建立连接则应该在响应的报文段中将SYN=1,ACK=1，表示接受请求</li>
<li>FIN终止控制位：用来释放连接，当FIN=1时表示此报文段发送方的数据已经发送完毕，并要求释放连接。</li>
<li>窗口（2字节）：用来告知发送端，接收端的缓存大小，以此控制发送方发送数据的速率，从而达到流量控制，窗口最大为65536</li>
<li>校验和：用CRC来校验整个TCP报文段，包括tcp头，tcp数据，由发送端进行计算和存储，接收端进行校验，如果接收方发现校验和有差错，则TCP段会被直接丢弃，在计算校验和时，要再TCP报文段的前面加上12字节的伪首部</li>
<li>紧急指针（2字节）：紧急指针指出在本报文段中的紧急数据的最后一个字节的序号    </li>
<li>选项部分：长度可变 TCP只规定一种选项，即最大报文段长度MMS(Maxium Segment Size)，MSS告诉对方TCP我的缓存所能接收的报文段的数据字段的最大长度时MSS个字节,只出现在SYN=1的报文段<pre><code>      MTU:最大传输单元（maximum transmission unit） 1500Byte
MSS = MTU-20Byte(IP首部)-20Byte(TCP首部)  一般情况下
</code></pre></li>
<li>填充：使整个首部的长度是4字节的整数倍</li>
</ul>
<h2 id="TCP-三次握手和四次挥手过程详解"><a href="#TCP-三次握手和四次挥手过程详解" class="headerlink" title="TCP 三次握手和四次挥手过程详解"></a>TCP 三次握手和四次挥手过程详解</h2><ul>
<li>用三次握手建立TCP连接</li>
</ul>
<ul>
<li>客户A  主动打开                                                  服务器B 被动打开<pre><code>连接请求SYN_SENT--------------SYN,SEQ=X---------------------------&gt;
          &lt;--------SYN+ACK,SEQ = y,ACK = x+1 rwnd:5000------------确认SYN_RECV
   确认ESTIBLISHD--------------ACK,SEQ =x+1,ACK = y+1 rwnd:10000-----&gt;
</code></pre></li>
</ul>
<ul>
<li>用四次挥手释放连接</li>
</ul>
<ul>
<li><p>主机A</p>
<pre><code> 应用进程释放连接------------------------FIN,SEQ =x-------------------&gt;通知主机应用进程
A不再发送报文
&lt;--------------------ACK,SEQ = y,ACK =x+1--------------------------确认
(从A到B的连接就释放了，连接处于半关闭状态。相当于A对B说，但你如果还发送数据，我仍接收)
    &lt;------------------FIN,ACK,SEQ = y,ACK = x+1-----------------------应用进程释放连接
</code></pre><p>​                                                                                                                                     B不在发送报文<br>​            确认———————–ACK,SEQ = x+1,ACk =y+1——————-&gt;</p>
</li>
<li><p>SYN 洪泛攻击  拒绝式服务攻击    <a href="https://cloud.tencent.com/developer/article/1489622" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1489622</a></p>
</li>
</ul>
<h2 id="TCP确认机制和窗口机制分析"><a href="#TCP确认机制和窗口机制分析" class="headerlink" title="TCP确认机制和窗口机制分析"></a>TCP确认机制和窗口机制分析</h2><ul>
<li>确认机制：<br>在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</li>
<li>窗口机制：<br><a href="https://blog.csdn.net/m0_37962600/article/details/79951780" target="_blank" rel="noopener">https://blog.csdn.net/m0_37962600/article/details/79951780</a></li>
</ul>
<h2 id="UDP协议的特点"><a href="#UDP协议的特点" class="headerlink" title="UDP协议的特点"></a>UDP协议的特点</h2><ul>
<li>UDP长度 = UDP头部 +数据部分</li>
<li>UDP长度 = IP长度 -IP的首部长度</li>
<li>无连接    不可靠</li>
<li>UDP协议的责任<ul>
<li>创建进程到进程间的通信(由端口号完成)</li>
<li>有限的差错控制，出现差错悄悄丢弃报文分组</li>
<li>Stream index 流索引        由源IP 源端口Port    目的IP 目的端口Port</li>
</ul>
</li>
<li>基于TCP的应用层:FTP        Telnet    Http   SMTP</li>
<li>基于UDP的应用层:DNS     TFTP      SNMP</li>
</ul>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><ul>
<li>网页浏览：HTTP        SSL</li>
<li>文件传输：FTP        TFTP</li>
<li>E-mail：  SMTP        POP3</li>
<li>远程登录：Telnet    SSH</li>
<li>网络管理：SNMP</li>
<li>域名服务：DNS </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ytalyq.top/2020/04/18/VScode快捷键/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清衍之">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyz.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="呼啸山庄的哑舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/18/VScode快捷键/" itemprop="url">VScode快捷键</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-18T14:43:28+08:00">
                2020-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="VScode快捷键"><a href="#VScode快捷键" class="headerlink" title="VScode快捷键"></a>VScode快捷键</h1><ol>
<li>注释：　　<br>单行注释：[ctrl+k,ctrl+c] 或 ctrl+/　<br>取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u)　　<br>多行注释：[alt+shift+A]　<br>多行注释：/**</li>
<li>移动行：alt+up/down</li>
<li>显示/隐藏左侧目录栏 ctrl + b</li>
<li>复制当前行：shift + alt +up/down</li>
<li>删除当前行：shift + ctrl + k</li>
<li>控制台终端显示与隐藏：ctrl + ~</li>
<li>查找文件/安装vs code 插件地址：ctrl + p</li>
<li>代码格式化：shift + alt +f</li>
<li>新建一个窗口: ctrl + shift + n1</li>
<li>行增加缩进: ctrl + [</li>
<li>行减少缩进: ctrl + ]</li>
<li>裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x</li>
<li>字体放大/缩小: ctrl + ( + 或 - )</li>
<li>拆分编辑器 :ctrl + 1/2/3</li>
<li>切换窗口: ctrl + shift + left/right</li>
<li>关闭编辑器窗口: ctrl + w</li>
<li>关闭所有窗口 : ctrl + k + w</li>
<li>切换全屏 :F11</li>
<li>自动换行: alt + z</li>
<li>显示git: ctrl + shift + g</li>
<li>全局查找文件：ctrl + p</li>
<li>显示相关插件的命令(如：git log)：ctrl + shift + p</li>
<li>选中文字：shift + left / right / up / down</li>
<li>折叠代码： ctrl + k + 0-9 (0是完全折叠)</li>
<li>展开代码： ctrl + k + j (完全展开代码)</li>
<li>删除行 ： ctrl + shift + k</li>
<li>快速切换主题：ctrl + k / ctrl + t</li>
<li>快速回到顶部 ： ctrl + home</li>
<li>快速回到底部 : ctrl + end</li>
<li>格式化选定代码 ：ctrl + k / ctrl +f</li>
<li>选中代码 ： shift + 鼠标左键</li>
<li>多行同时添加内容（光标） ：ctrl + alt + up/down</li>
<li>全局替换：ctrl + shift + h</li>
<li>当前文件替换：ctrl + h</li>
<li>打开最近打开的文件：ctrl + r</li>
<li>打开新的命令窗：ctrl + shift + c</li>
<li>直接跳转下一行： ctrl + enter</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ytalyq.top/2020/04/18/Typora快捷键/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清衍之">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyz.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="呼啸山庄的哑舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/18/Typora快捷键/" itemprop="url">Typora快捷键</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-18T14:40:57+08:00">
                2020-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><h2 id="一：菜单栏"><a href="#一：菜单栏" class="headerlink" title="一：菜单栏"></a>一：菜单栏</h2><ul>
<li>文件：alt+F</li>
<li>编辑：alt+E</li>
<li>段落：alt+P</li>
<li>格式：alt+O</li>
<li>视图：alt+V</li>
<li>主题：alt+T</li>
<li>帮助：alt+H</li>
</ul>
<h2 id="二：文件"><a href="#二：文件" class="headerlink" title="二：文件"></a>二：文件</h2><ul>
<li>新建：Ctrl+N</li>
<li>新建窗口：Ctrl+Shift+N</li>
<li>打开：Ctrl+O</li>
<li>快速打开：Ctrl+P</li>
<li>保存：Ctrl+S</li>
<li>另存为：Ctrl+Shift+S</li>
<li>偏好：Ctrl+,</li>
<li>关闭：Ctrl+W</li>
</ul>
<h2 id="三：编辑"><a href="#三：编辑" class="headerlink" title="三：编辑"></a>三：编辑</h2><ul>
<li>撤销：Ctrl+Z</li>
<li>重做：Ctrl+Y</li>
<li>剪切：Ctrl+X</li>
<li>复制：Ctrl+C</li>
<li>粘贴：Ctrl+V</li>
<li>复制为MarkDown：Ctrl+Shift+C</li>
<li>粘贴为纯文本：Ctrl+Shift+V</li>
<li>全选：Ctrl+A</li>
<li>选中当前行/句：Ctrl+L</li>
<li>选中当前格式文本：Ctrl+E</li>
<li>选中当前词：Ctrl+D</li>
<li>跳转到下一行：Ctrl+Enter</li>
<li>跳转到文首：Ctrl+Home</li>
<li>跳转到所选内容：Ctrl+J</li>
<li>跳转到文末：Ctrl+End</li>
<li>查找：Ctrl+F</li>
<li>查找下一个：F3</li>
<li>查找上一个：Shift+F3</li>
<li>替换：Ctrl+H</li>
</ul>
<h2 id="四：段落"><a href="#四：段落" class="headerlink" title="四：段落"></a>四：段落</h2><ul>
<li>标题：Ctrl+1/2/3/4/5</li>
<li>段落：Ctrl+0</li>
<li>增大标题级别：Ctrl+=</li>
<li>减少标题级别：Ctrl+-</li>
<li>表格：Ctrl+T</li>
<li>代码块：Ctrl+Shift+K</li>
<li>公式块：Ctrl+Shift+M</li>
<li>引用：Ctrl+Shift+Q</li>
<li>有序列表：Ctrl+Shift+[</li>
<li>无序列表：Ctrl+Shift+]</li>
<li>增加缩进：Ctrl+]</li>
<li>减少缩进：Ctrl+[</li>
</ul>
<h2 id="五：格式"><a href="#五：格式" class="headerlink" title="五：格式"></a>五：格式</h2><ul>
<li>加粗：Ctrl+B</li>
<li>斜体：Ctrl+I</li>
<li>下划线：Ctrl+U</li>
<li>代码：Ctrl+Shift+`</li>
<li>删除线：Alt+Shift+5</li>
<li>超链接：Ctrl+K</li>
<li>图像：Ctrl+Shift+I</li>
<li>清除样式：Ctrl+</li>
</ul>
<h2 id="六：视图"><a href="#六：视图" class="headerlink" title="六：视图"></a>六：视图</h2><ul>
<li>显示隐藏侧边栏：Ctrl+Shift+L</li>
<li>大纲视图：Ctrl+Shift+1</li>
<li>文档列表视图：Ctrl+Shift+2</li>
<li>文件树视图：Ctrl+Shift+3</li>
<li>源代码模式：Ctrl+/</li>
<li>专注模式：F8</li>
<li>打字机模式：F9</li>
<li>切换全屏：F11</li>
<li>实际大小：Ctrl+Shift+0</li>
<li>放大：Ctrl+Shift+=</li>
<li>缩小：Ctrl+Shift+-</li>
<li>应用内窗口切换：Ctrl+Tab</li>
<li>打开DevTools：Shift+F12</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ytalyq.top/2019/08/02/Java开发实习生面试问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清衍之">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyz.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="呼啸山庄的哑舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/02/Java开发实习生面试问题/" itemprop="url">Java开发实习生面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-02T10:39:40+08:00">
                2019-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java开发实习生面试题"><a href="#Java开发实习生面试题" class="headerlink" title="Java开发实习生面试题"></a>Java开发实习生面试题</h1><h2 id="数据库连接的步骤？"><a href="#数据库连接的步骤？" class="headerlink" title="数据库连接的步骤？"></a>数据库连接的步骤？</h2><ol>
<li>加载驱动</li>
<li>提供JDBC连接的URL</li>
<li>创建数据库连接</li>
<li>创建一个Statement对象</li>
<li>执行sql语句</li>
<li>.返回ResultSet结果集</li>
<li>关闭JDBC对象</li>
</ol>
<h2 id="TCP三次握手？"><a href="#TCP三次握手？" class="headerlink" title="TCP三次握手？"></a>TCP三次握手？</h2><ol>
<li>客户端发送syn包到服务器</li>
<li>服务器收到syn包，并发送一个syn+ack的包</li>
<li>客户端收到syn+ack的包，并向服务器发送ack确认包</li>
</ol>
<h2 id="什么是AOP？用自己的话语简述？"><a href="#什么是AOP？用自己的话语简述？" class="headerlink" title="什么是AOP？用自己的话语简述？"></a>什么是AOP？用自己的话语简述？</h2><ul>
<li>面向对象编程：万物皆对象</li>
</ul>
<h2 id="面向对象的三大基本特征和五大基本原则？"><a href="#面向对象的三大基本特征和五大基本原则？" class="headerlink" title="面向对象的三大基本特征和五大基本原则？"></a>面向对象的三大基本特征和五大基本原则？</h2><ul>
<li>三大特性：（1）封装（2）继承（3）多态</li>
<li>五大基本原则：（1）单一职责原则（2）开放封闭原则（3）替换原则（4）依赖原则（5）接口分离原则</li>
</ul>
<h2 id="Java中23种设计模式？"><a href="#Java中23种设计模式？" class="headerlink" title="Java中23种设计模式？"></a>Java中23种设计模式？</h2><ol>
<li>创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式</li>
<li>结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式</li>
<li>行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ol>
<h2 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h2><ul>
<li>对象关系映射(英语:(Object Relational Mapping，简称ORM，或O/RM，或O/R mapping)，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换 。从效果上说，它其实是创建了一个可在编程语言里使用的–”虚拟对象数据库”。</li>
</ul>
<h2 id="SSM（Spring-SpringMVC-Mybatis）框架的优势？"><a href="#SSM（Spring-SpringMVC-Mybatis）框架的优势？" class="headerlink" title="SSM（Spring+SpringMVC+Mybatis）框架的优势？"></a>SSM（Spring+SpringMVC+Mybatis）框架的优势？</h2><ol>
<li>Spring的优势：（1）通过Spring的IOC特性，将对象之间的依赖关系交给了Spring控制，方便解耦，简化开发（2）通过SpringAOP的特性，对重复模块进行集中，实现事务，日志，权限的控制</li>
<li>SpringMVC的优势：（1）对web层进行解耦，使我们开发更简洁与Spring无缝衔接</li>
<li>Mybatis的优势：（1）数据库的操作（sql）采用xml文件配置，解除了sql和代码的耦合（2）提供映射标签，支持对象和数据库字段关系的映射（2）提供了xml标签，支持动态sql</li>
</ol>
<h2 id="SpringAOP是什么意思？"><a href="#SpringAOP是什么意思？" class="headerlink" title="SpringAOP是什么意思？"></a>SpringAOP是什么意思？</h2><ol>
<li>切面编程，就是在你项目原有的功能基础上，通过AOP去添加新的功能</li>
<li>客户端通过url发送请求</li>
<li>核心控制器dispatcherServlet通过自定义的或系统的映射器找到对应的handler，并将url映射的控制器controller（控住器）返回给核心控制器</li>
<li>通过核心控制器找到系统或默认的适配器</li>
<li>由找到的适配器调用实现对应接口的处理器，并将结果返回给适配器，结果中包含数据模型和视图对象，再由适配器返回给核心控制器</li>
<li>核心控制器将获取的数据和视图结合的对象传递给视图解析器，视图解析器解析之后得到结果，并由视图解析器响应给核心控制器</li>
<li>核心控制器将结果返回给客户端</li>
</ol>
<h2 id="SpringMVC和Struts2的区别？"><a href="#SpringMVC和Struts2的区别？" class="headerlink" title="SpringMVC和Struts2的区别？"></a>SpringMVC和Struts2的区别？</h2><ol>
<li>SpringMVC是基于方法开发（一个url对应一个方法），传递参数传递到方法的形参，可以设计单例或者多例（多为单例），Struts2是基于类开发，传递参数通过类的属性，只能设计多例</li>
<li>SpringMVC入口是一个servlet（前端控制器），而Struts2是filter（过滤器）</li>
<li>SpringMVC集成了Ajax，只需要一个@ResponseBody就可以实现，使用方便，Struts2拦截器集成了Ajax，在Action中处理一般安装插件或者自己写一段代码集成进去，使用不方便</li>
<li>SpringMVC支持JSR303验证，处理更加方便，Struts2验证繁琐</li>
<li>Struts2更加符合OOP的编程思维，SpringMVC就比较严谨，在servlet上扩展</li>
<li>SpringMVC开发效率高于Struts2</li>
</ol>
<h2 id="JSP和servlet的区别和联系？"><a href="#JSP和servlet的区别和联系？" class="headerlink" title="JSP和servlet的区别和联系？"></a>JSP和servlet的区别和联系？</h2><ol>
<li>jsp经编译后就变成了Servlet（JSP的本质就是servlet，JVM只能识别java类，不能识别JSP代码）</li>
<li>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制</li>
<li>servlet中没有内置对象，jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到</li>
</ol>
<h2 id="什么是JSP？特点是什么？"><a href="#什么是JSP？特点是什么？" class="headerlink" title="什么是JSP？特点是什么？"></a>什么是JSP？特点是什么？</h2><ol>
<li>JSP：是以Java语言为基础的动态网页开发技术</li>
<li>特点：（1）Servlet特点：在Java源码中嵌入html源码（2）JSP特点：在html源码中嵌入java代码</li>
</ol>
<h2 id="html（超文本标记语言）和jsp的区别？"><a href="#html（超文本标记语言）和jsp的区别？" class="headerlink" title="html（超文本标记语言）和jsp的区别？"></a>html（超文本标记语言）和jsp的区别？</h2><ol>
<li>html能直接打开，jsp只能发布到tomcat等服务器上才能打开</li>
<li>定义上html是静态页面可以直接运行，jsp动态页，他运行是需要转换为servlet</li>
</ol>
<h2 id="html的优缺点和jsp的优缺点？"><a href="#html的优缺点和jsp的优缺点？" class="headerlink" title="html的优缺点和jsp的优缺点？"></a>html的优缺点和jsp的优缺点？</h2><ol>
<li>html优点：（1）开发过程中前后端分离，交互通过JSON传输来实现（2）跨平台能力更强，依托于浏览器的支持（3）使用后台数据接口能够得到复用</li>
<li>html缺点：（1）开发难度大，考虑浏览器的兼容性（2）页面请求过多（3）属于后加载，无法被爬虫爬到（4）接口代码需要新增很多（5）无法直接显示java实体类对象，需要转换为JSON格式</li>
<li>jsp优点：（1）可被爬虫爬到（2）减少请求次数（3）不考虑浏览器的兼容性</li>
<li>jsp缺点：（1）增大了服务器的压力（2）前后端未分离，开发速度慢（3）过于依赖java运行环境（4）复用性低</li>
</ol>
<h2 id="html和xml的区别？"><a href="#html和xml的区别？" class="headerlink" title="html和xml的区别？"></a>html和xml的区别？</h2><ol>
<li>语法要求不同：（1）在html中不区分大小写，在xml中严格区分</li>
<li>标记不同：（1）html使用固有的标记；而xml没有固有的标记。</li>
<li>作用不同：（1）html是用来显示数据的；xml是用来描述数据、存放数据的</li>
<li>xml不是要来取代html的，是对html的补充，用来与html协同工作的语言</li>
</ol>
<h2 id="jsp九大内置对象"><a href="#jsp九大内置对象" class="headerlink" title="jsp九大内置对象"></a>jsp九大内置对象</h2><ol>
<li>request</li>
<li>response</li>
<li>session</li>
<li>out</li>
<li>page</li>
<li>pageContext</li>
<li>application</li>
<li>config</li>
<li>exception</li>
</ol>
<h2 id="Ajax之同步请求和异步请求的区别？"><a href="#Ajax之同步请求和异步请求的区别？" class="headerlink" title="Ajax之同步请求和异步请求的区别？"></a>Ajax之同步请求和异步请求的区别？</h2><ol>
<li>同步是指：发送方发出数据后，等接收方发回响应以后，才发下一个数据包的通讯方式。</li>
<li>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</li>
</ol>
<h2 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h2><ol>
<li>cookie数据存放在客户的浏览器上，session数据存放在服务器上</li>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，session安全</li>
<li>session会在一定时间内保存在服务器上，当访问增多时，会比较占用你服务器的性能，考虑到减轻服务器的性能方面，应当使用cookie</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</li>
<li>可以考虑将登陆信息等重要的信息保存在session，其他信息需要保留，可以放在cookie中</li>
</ol>
<h2 id="String和StringBuild和StringBuffer"><a href="#String和StringBuild和StringBuffer" class="headerlink" title="String和StringBuild和StringBuffer"></a>String和StringBuild和StringBuffer</h2><ol>
<li>速度上：StringBuild&gt;StringBuffer&gt;String</li>
<li>String是字符串常量，一旦声明不可改变</li>
<li>StringBuild是线程不安全，StringBuffter是线程安全</li>
<li>StringBuffer中很多方法带有synchronized关键字，所以可以保证线程安全，但StringBuild中没有关键字，所以保证不了线程安全</li>
<li>String：适用于少量字符串操作的情况，即创建复制，修改的比较少情况</li>
<li>StringBuffer：适用于单线程下字符串缓冲区进行大量操作的情况</li>
<li>StringBuild：适用于多线程下字符串缓冲区进行大量的操作情况</li>
</ol>
<h2 id="java垃圾自动回收机制"><a href="#java垃圾自动回收机制" class="headerlink" title="java垃圾自动回收机制"></a>java垃圾自动回收机制</h2><ul>
<li>java垃圾回收机制是java虚拟机提供的功能，用于空闲的时间以不定时的方式动态回收无任何引用的对象所占据的内存空间</li>
</ul>
<h2 id="集合的三大类"><a href="#集合的三大类" class="headerlink" title="集合的三大类"></a>集合的三大类</h2><ul>
<li>Set（无序）：存储单列数据的集合，存储的数据是无顺序的，并且不允许重复，最常用的是HashSet</li>
<li>List（有序）：存储单列数据的集合，存储的数据是有顺序的，并且值允许重复，最常用的是</li>
<li>ArrayList</li>
<li>Map：存储键值对这样的双列数据集合，存储的数据是无序的，它的键是不允许重复的，但是值是允许重复的，最常用的是HashMap</li>
</ul>
<h2 id="什么是接口？java为什么需要接口？"><a href="#什么是接口？java为什么需要接口？" class="headerlink" title="什么是接口？java为什么需要接口？"></a>什么是接口？java为什么需要接口？</h2><ol>
<li>接口：接口就是某个事物对外提供一些功能的声明，是一种特殊的java类</li>
<li>为什么需要接口：为了弥补java单继承的缺陷</li>
</ol>
<h2 id="ArryList和LinkedList的区别？"><a href="#ArryList和LinkedList的区别？" class="headerlink" title="ArryList和LinkedList的区别？"></a>ArryList和LinkedList的区别？</h2><ol>
<li>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表</li>
<li>对于随机访问，ArrayList优于LinkedList</li>
<li>对于插入和删除操作，LinkedList优于ArrayList</li>
<li>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了索引，一个指向前一个元素，一个指向后一个元素</li>
</ol>
<h2 id="List和ArrayList的区别？"><a href="#List和ArrayList的区别？" class="headerlink" title="List和ArrayList的区别？"></a>List和ArrayList的区别？</h2><ol>
<li>List是一个接口，定义了一些方法，但是这些方法没有被实现</li>
<li>ArrayList是一个类，实现了List这个接口里面定义的方法</li>
</ol>
<h2 id="抽象类和接口的相同点和区别？"><a href="#抽象类和接口的相同点和区别？" class="headerlink" title="抽象类和接口的相同点和区别？"></a>抽象类和接口的相同点和区别？</h2><ul>
<li><p>相同点：</p>
<ol>
<li>都是上层的抽象层</li>
<li>都不能被实例化</li>
<li>都能包含抽象方法，这些抽象方法用于描述具备的功能，但是不必提供具体的实现</li>
</ol>
</li>
<li><p>区别：</p>
<ol>
<li>抽象类要被子类继承；接口要被类实现</li>
<li>抽象类可以做方法申明，也可以做方法实现；接口只能做方法申明</li>
<li>抽象类中的变量是普通变量；接口里定义的变量只能是公共的静态常量</li>
<li>抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象的方法，那么子类只能是抽象类；同样，实现接口的时候，如果不能全部实现接口方法，那么该类也只能是抽象类</li>
<li>接口是设计的结果，抽象类是重构的结果</li>
<li>抽象类里面可以没有抽象方法</li>
<li>如果一个类里有抽象方法，那么这个类只能是抽象类</li>
<li>抽象方法要被实现，所以不能是静态的，也不能是私有的</li>
<li>接口可继承接口，并可多继承接口，但类只能单继承</li>
</ol>
</li>
</ul>
<h2 id="什么是重写？什么是重载？方法重写和重载的区别？"><a href="#什么是重写？什么是重载？方法重写和重载的区别？" class="headerlink" title="什么是重写？什么是重载？方法重写和重载的区别？"></a>什么是重写？什么是重载？方法重写和重载的区别？</h2><ul>
<li>重写：存在子父类之间的，子类拥有与父类相同的方法名，相同的参数和返回类型</li>
<li>重载：同一个类中拥有相同的方法名，但参数数量或参数类型不能完全相同</li>
<li>区别：重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。<ol>
<li>重载方法参数列表必须修改，重写方法一定不能修改</li>
<li>重载方法返回类型可以修改，重写方法返回类型一定不能修改</li>
<li>重载方法可以修改异常，重写方法可以减少或者删除，但不能抛出新的或更广的异常</li>
<li>重载方法可以修改访问，重写方法不能做严格的限制</li>
</ol>
</li>
</ul>
<h2 id="什么是Redis？特点是什么？"><a href="#什么是Redis？特点是什么？" class="headerlink" title="什么是Redis？特点是什么？"></a>什么是Redis？特点是什么？</h2><ul>
<li>Redis：一款内存高速缓存数据库</li>
<li>特点：Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。Redis支持主从模式，可以配置集群，这样更利于支撑起大型的项目，这也是Redis的一大亮点。</li>
</ul>
<h2 id="JVM内存的划分？"><a href="#JVM内存的划分？" class="headerlink" title="JVM内存的划分？"></a>JVM内存的划分？</h2><ol>
<li>寄存器</li>
<li>本地方法区</li>
<li>方法区</li>
<li>栈内存</li>
<li>堆内存</li>
</ol>
<h2 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h2><ul>
<li>堆是先进先出，栈是先进后出</li>
<li>栈内存：存储的是局部变量，凡是定义在方法中的都是局部变量（方法外的都是全部变量）</li>
<li>堆内存：存储的是数组和对象，凡是new建立的都是在堆中，堆中存放的都是实体（对象）</li>
<li>指针：栈中的变量指向堆内存中的变量，这就是Java中的指针<ol>
<li>栈内存存储的局部变量，而堆内存存储的是实体</li>
<li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短</li>
<li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li>
</ol>
</li>
</ul>
<h2 id="请求转发（forward）和重定向（redirect）的区别？"><a href="#请求转发（forward）和重定向（redirect）的区别？" class="headerlink" title="请求转发（forward）和重定向（redirect）的区别？"></a>请求转发（forward）和重定向（redirect）的区别？</h2><ol>
<li>请求转发是在服务端的，重定向是在客户端的</li>
<li>请求转发速度快，重定向速度慢</li>
<li>请求转发是同一次请求，重定向是两次不同的请求</li>
<li>请求转发地址栏不会发生变化，重定向地址栏会发生变化</li>
<li>请求转发不会执行转发后的代码，重定向会执行转发后的代码</li>
<li>请求转发必须在同一服务器下完成，重定向可以在不同服务器下完成</li>
</ol>
<h2 id="如何进行数据库优化？"><a href="#如何进行数据库优化？" class="headerlink" title="如何进行数据库优化？"></a>如何进行数据库优化？</h2><ol>
<li>建立索引 create index（索引名） on 表名（字段）索引包括聚集索引，覆盖索引，复合索引</li>
<li>拆分表</li>
<li>增加中间表</li>
</ol>
<h2 id="拦截器和过滤器的区别？"><a href="#拦截器和过滤器的区别？" class="headerlink" title="拦截器和过滤器的区别？"></a>拦截器和过滤器的区别？</h2><ol>
<li>拦截器是基于java反射机制的，过滤器是基于函数回调</li>
<li>拦截器不依赖于servlet容器，过滤器依赖于servlet容器</li>
<li>拦截器只能对action请求起作用，而过滤器可以对几乎所有的请求起作用</li>
<li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问</li>
<li>在action的声明周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次</li>
<li>拦截器可以获取IOC容器中的各个bean，而过滤器不行，在拦截去里注入一个service，可以调用业务逻辑</li>
<li>拦截器需要在Spring配置文件中配置，过滤器只需要在web.xml中配置</li>
</ol>
<h2 id="Mybatis和Hibernate的区别？"><a href="#Mybatis和Hibernate的区别？" class="headerlink" title="Mybatis和Hibernate的区别？"></a>Mybatis和Hibernate的区别？</h2><ol>
<li>hibernate是全自动，而mybatis是半自动</li>
<li>hibernate数据库移植性远大于mybatis</li>
<li>hibernate拥有完整的日志系统，mybatis则欠缺一些</li>
<li>mybatis相比hibernate需要关心很多细节</li>
<li>sql直接优化上，mybatis要比hibernate方便很多</li>
</ol>
<h2 id="SSM和SSH的各自优势？"><a href="#SSM和SSH的各自优势？" class="headerlink" title="SSM和SSH的各自优势？"></a>SSM和SSH的各自优势？</h2><ol>
<li>MyBatis可以进行更为细致的SQL优化，可以减少查询字段</li>
<li>MyBatis容易掌握，而Hibernate门槛较高</li>
<li>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。</li>
<li>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。</li>
<li>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。</li>
<li>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳，更新操作不能指定刷新指定记录，会清空整个表，但是也可以使用第三方缓存。</li>
<li>Hibernate 封装性好，屏蔽了数据库差异，自动生成SQL语句，应对数据库变化能力较弱，SQL语句优化困难。</li>
<li>MyBatis仅实现了SQL语句和对象的映射，需要针对具体的数据库写SQL语句，应对数据库变化能力较强，SQL语句优化较为方便。</li>
</ol>
<h2 id="hibernate的一级缓存和二级缓存？"><a href="#hibernate的一级缓存和二级缓存？" class="headerlink" title="hibernate的一级缓存和二级缓存？"></a>hibernate的一级缓存和二级缓存？</h2><ol>
<li>一级缓存：就是session级别的缓存，一个session做了一个查询操作，它就会把这个操作的结果存放在一级缓存中</li>
<li>二级缓存：如果短时间内（一定要同一个session）又做了同一操作，那么hibernate直接从一级缓存中拿，就不会去连接数据库，取数据了，就是SessionFactory级别的缓存</li>
</ol>
<h2 id="什么是B-S架构？什么是C-S架构？"><a href="#什么是B-S架构？什么是C-S架构？" class="headerlink" title="什么是B/S架构？什么是C/S架构？"></a>什么是B/S架构？什么是C/S架构？</h2><ul>
<li>B/S(Browser/Server)，浏览器/服务器程序</li>
<li>C/S(Client/Server)，客户端/服务端，桌面应用程序</li>
</ul>
<h2 id="你所知道网络协议有那些？"><a href="#你所知道网络协议有那些？" class="headerlink" title="你所知道网络协议有那些？"></a>你所知道网络协议有那些？</h2><ol>
<li>HTTP：超文本传输协议</li>
<li>FTP：文件传输协议</li>
<li>SMPT：简单邮件协议</li>
<li>TELNET：远程终端协议</li>
<li>POP3：邮件读取协议</li>
<li>TCP/IP:  网络通信协议</li>
</ol>
<h2 id="Java都有那些开发平台？"><a href="#Java都有那些开发平台？" class="headerlink" title="Java都有那些开发平台？"></a>Java都有那些开发平台？</h2><ul>
<li>JAVA SE：主要用在客户端开发</li>
<li>JAVA EE：主要用在web应用程序开发</li>
<li>JAVA ME：主要用在嵌入式应用程序开发</li>
</ul>
<h2 id="什么是JVM？java虚拟机包括什么？"><a href="#什么是JVM？java虚拟机包括什么？" class="headerlink" title="什么是JVM？java虚拟机包括什么？"></a>什么是JVM？java虚拟机包括什么？</h2><ul>
<li>JVM：java虚拟机，运用硬件或软件手段实现的虚拟的计算机，Java虚拟机包括：寄存器，堆栈，处理器</li>
</ul>
<h2 id="什么是JDK？什么是JRE"><a href="#什么是JDK？什么是JRE" class="headerlink" title="什么是JDK？什么是JRE?"></a>什么是JDK？什么是JRE?</h2><ul>
<li>JDK：java development kit：java开发工具包，是开发人员所需要安装的环境</li>
<li>.JRE：java runtime environment：java运行环境，java程序运行所需要安装的环境</li>
</ul>
<h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><ul>
<li>计算机保存，组织数据的方式</li>
</ul>
<h2 id="Java的数据结构有那些？"><a href="#Java的数据结构有那些？" class="headerlink" title="Java的数据结构有那些？"></a>Java的数据结构有那些？</h2><ol>
<li>线性表（ArrayList）</li>
<li>链表（LinkedList）</li>
<li>栈（Stack）</li>
<li>队列（Queue）</li>
<li>图（Map）</li>
<li>树（Tree）</li>
</ol>
<h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系?"></a>类与对象的关系?</h2><ul>
<li>类是对象的抽象，对象是类的具体，类是对象的模板，对象是类的实例</li>
</ul>
<h2 id="java八大基本数据类型"><a href="#java八大基本数据类型" class="headerlink" title="java八大基本数据类型"></a>java八大基本数据类型</h2><ul>
<li>byte</li>
<li>short</li>
<li>long</li>
<li>int</li>
<li>float</li>
<li>double</li>
<li>char</li>
<li>boolean</li>
</ul>
<h2 id="程序的结构有那些？"><a href="#程序的结构有那些？" class="headerlink" title="程序的结构有那些？"></a>程序的结构有那些？</h2><ul>
<li>顺序结构</li>
<li>选择结构</li>
<li>循环结构</li>
</ul>
<h2 id="数组实例化有几种方式？"><a href="#数组实例化有几种方式？" class="headerlink" title="数组实例化有几种方式？"></a>数组实例化有几种方式？</h2><ol>
<li>静态实例化：创建数组的时候已经指定数组中的元素</li>
<li>动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值</li>
</ol>
<h2 id="Static关键字有什么作用？"><a href="#Static关键字有什么作用？" class="headerlink" title="Static关键字有什么作用？"></a>Static关键字有什么作用？</h2><ol>
<li>Static可以修饰内部类、方法、变量、代码块</li>
<li>Static修饰的类是静态内部类</li>
<li>Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。</li>
<li>Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。</li>
<li>Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。</li>
</ol>
<h2 id="Final在java中的作用？"><a href="#Final在java中的作用？" class="headerlink" title="Final在java中的作用？"></a>Final在java中的作用？</h2><ol>
<li>Final可以修饰类，修饰方法，修饰变量。</li>
<li>修饰的类叫最终类。该类不能被继承。</li>
<li>修饰的方法不能被重写。</li>
<li>修饰的变量叫常量，常量必须初始化，一旦初始化后，常量的值不能发生改变。</li>
</ol>
<h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><ul>
<li>&amp;是位运算符。&amp;&amp;是布尔逻辑运算符，在进行逻辑判断时用&amp;处理的前面为false后面的内容仍需处理，用&amp;&amp;处理的前面为false不再处理后面的内容。</li>
</ul>
<h2 id="HashMap和HashTable之间的区别？"><a href="#HashMap和HashTable之间的区别？" class="headerlink" title="HashMap和HashTable之间的区别？"></a>HashMap和HashTable之间的区别？</h2><ol>
<li>初始化时机不同</li>
<li>默认数组大小不同，在HashTable中，hash数组默认大小是11，在HashMap中，hash数组默认大小是16</li>
<li>HashMap允许（null）键值（key），而HashTable不允许</li>
<li>HashMap把HashTable的contains（）方法去掉了，改了containsValues（）和containsKey（）</li>
<li>Hashtable的方法是线程安全的，HashMap不支持线程的同步，不是线程安全的</li>
<li>Hashtable使用Enumeration,HashMap使用Iterator（继承不同）</li>
<li>hash值的使用不同，HashTable直接使用对象的hashCode</li>
</ol>
<h2 id="jdk1-7和jdk1-8的区别？"><a href="#jdk1-7和jdk1-8的区别？" class="headerlink" title="jdk1.7和jdk1.8的区别？"></a>jdk1.7和jdk1.8的区别？</h2><ol>
<li>二进制变量的表示以0b开头</li>
<li>Switch语句支持String类型</li>
<li>多了try-with-resource语句</li>
<li>数字类型的下划线更加友好</li>
<li>创建泛型实例时，会根据变量声明时的泛型类型自动推断出实例的泛型类型</li>
<li>try块可以不用finally手动关闭，直接try块中就可以关闭</li>
</ol>
<h2 id="和equals的区别？"><a href="#和equals的区别？" class="headerlink" title="==和equals的区别？"></a>==和equals的区别？</h2><ul>
<li>==：用来比较值是否相等</li>
<li>equals：用来比较是否同一个对象</li>
</ul>
<h2 id="js“-”和“-”的区别？"><a href="#js“-”和“-”的区别？" class="headerlink" title="js“==”和“===”的区别？"></a>js“==”和“===”的区别？</h2><ul>
<li>==：用于一般比较，比较的时候可以转换数据类型</li>
<li>===：用于严格比较，只要类型不匹配就返回false</li>
</ul>
<h2 id="java“-”和equals的区别？"><a href="#java“-”和equals的区别？" class="headerlink" title="java“==”和equals的区别？"></a>java“==”和equals的区别？</h2><ul>
<li>==：分两种情况，（1）基本数据类型：比较是值是否相等（2）引用数据类型：比较的是地址值（堆内存地址）</li>
</ul>
<h2 id="Java设置定时器的步骤？"><a href="#Java设置定时器的步骤？" class="headerlink" title="Java设置定时器的步骤？"></a>Java设置定时器的步骤？</h2><ol>
<li>将自己写的监听器添加到web.xml种</li>
<li>写一个监听器，实现ServletContextListener接口</li>
<li>写一个定时器，继承TimerTask，复写run（）方法</li>
</ol>
<h2 id="Java设置定时器的三种方法？"><a href="#Java设置定时器的三种方法？" class="headerlink" title="Java设置定时器的三种方法？"></a>Java设置定时器的三种方法？</h2><ol>
<li>创建一个Thread，然后让它在while循环里运行，通过sleep（）方法来达到定时的效果（最常用的一种）</li>
</ol>
<h2 id="js设置定时器的两种方法？"><a href="#js设置定时器的两种方法？" class="headerlink" title="js设置定时器的两种方法？"></a>js设置定时器的两种方法？</h2><ol>
<li>setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</li>
<li>setTimeout() ：在指定的毫秒数后调用函数或计算表达式。</li>
</ol>
<h2 id="Web监听器"><a href="#Web监听器" class="headerlink" title="Web监听器"></a>Web监听器</h2><h3 id="什么是web监听器？"><a href="#什么是web监听器？" class="headerlink" title="什么是web监听器？"></a>什么是web监听器？</h3><ul>
<li>web监听器是一种servlet种特殊的类，它们能帮助开发者监听web中的特定事件，比如ServletContext,HttpSession,ServletRequest的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</li>
<li>监听器常见的用途？<ol>
<li>统计在线人数：利用HttpSessionListener</li>
<li>加载初始化信息：利用ServletContextListener</li>
<li>统计网站访问量</li>
<li>实现访问监控</li>
</ol>
</li>
</ul>
<h2 id="Java线程面试题目"><a href="#Java线程面试题目" class="headerlink" title="Java线程面试题目"></a>Java线程面试题目</h2><h3 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1.什么是线程？"></a>1.什么是线程？</h3><ul>
<li>线程是操作系统能够进行运算调度的最小单位</li>
</ul>
<h3 id="2-线程和进程有什么区别？优缺点？"><a href="#2-线程和进程有什么区别？优缺点？" class="headerlink" title="2.线程和进程有什么区别？优缺点？"></a>2.线程和进程有什么区别？优缺点？</h3><ol>
<li>根本区别：进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位<br>进程是独立的</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高<br>优缺点：线程执行开销小，但不利于资源的管理和保护，进程正好相反</li>
</ol>
<h3 id="3-什么是线程阻塞？"><a href="#3-什么是线程阻塞？" class="headerlink" title="3.什么是线程阻塞？"></a>3.什么是线程阻塞？</h3><ul>
<li>线程阻塞通常是指一个线程在执行过程中暂停，以等待某个条件的触发</li>
</ul>
<h3 id="4-什么是线程死锁？"><a href="#4-什么是线程死锁？" class="headerlink" title="4.什么是线程死锁？"></a>4.什么是线程死锁？</h3><ul>
<li>死锁是由于两个对象在拥有一份资源的情况下申请另一份资源，而另一份资源恰好又是这两个对象所持有的，导致两个对象无法完成操作，且所持资源无法释放。</li>
</ul>
<h3 id="5-Java如何实现线程？"><a href="#5-Java如何实现线程？" class="headerlink" title="5.Java如何实现线程？"></a>5.Java如何实现线程？</h3><ol>
<li>继承（extends）Thread类覆盖run（）方法即可，这中方法的缺点是，一个Java类只能继承一个父类</li>
<li>实现Runnable接口，实现run（）方法即可（最常用的方式），可满足Java多继承</li>
<li>implements Callable，实现call（）方法即可</li>
</ol>
<h3 id="6-Thread类中start（）和run（）方法的区别？"><a href="#6-Thread类中start（）和run（）方法的区别？" class="headerlink" title="6.Thread类中start（）和run（）方法的区别？"></a>6.Thread类中start（）和run（）方法的区别？</h3><ul>
<li>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run（）方法效果不一样，调用run（）方法时，只会是在原来的线程中调用，没有启动新的线程，start（）方法会启动新的线程</li>
</ul>
<h3 id="7-线程的5种状态？"><a href="#7-线程的5种状态？" class="headerlink" title="7.线程的5种状态？"></a>7.线程的5种状态？</h3><ul>
<li>五种状态：创建、就绪、运行、阻塞和死亡</li>
</ul>
<h3 id="8-Java中Runnable和Callable有什么不同？"><a href="#8-Java中Runnable和Callable有什么不同？" class="headerlink" title="8.Java中Runnable和Callable有什么不同？"></a>8.Java中Runnable和Callable有什么不同？</h3><ul>
<li>主要区别：Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能</li>
</ul>
<h3 id="9-Java中什么是竞态条件？"><a href="#9-Java中什么是竞态条件？" class="headerlink" title="9.Java中什么是竞态条件？"></a>9.Java中什么是竞态条件？</h3><ul>
<li>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。在临界区使用适当的同步就可以避免竞态条件。临界区有两种实现方法：（1）一种是用snychronized（2）用lock显示锁实现</li>
</ul>
<h3 id="10-如何在两个线程间共享数据？"><a href="#10-如何在两个线程间共享数据？" class="headerlink" title="10.如何在两个线程间共享数据？"></a>10.如何在两个线程间共享数据？</h3><ul>
<li>通过共享对象来实现这个目的</li>
</ul>
<h3 id="11-Java种notify和notifyAll有什么区别？"><a href="#11-Java种notify和notifyAll有什么区别？" class="headerlink" title="11.Java种notify和notifyAll有什么区别？"></a>11.Java种notify和notifyAll有什么区别？</h3><ul>
<li>notify()不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地</li>
<li>notifyAll（）唤醒所有线程并允许他们之间争夺锁，确保了至少有一个线程能继续运行</li>
</ul>
<h3 id="12-什么是线程池？"><a href="#12-什么是线程池？" class="headerlink" title="12.什么是线程池？"></a>12.什么是线程池？</h3><ul>
<li>线程池是一种多线程的处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务</li>
</ul>
<h3 id="13-Java种常用的三种线程池？"><a href="#13-Java种常用的三种线程池？" class="headerlink" title="13.Java种常用的三种线程池？"></a>13.Java种常用的三种线程池？</h3><ol>
<li>FixedThreadPool：这是一个线程数固定的线程池，当这个线程池被创建的时候，池里的线程数就已经固定了</li>
<li>SingleThreadExecutor：这是一个线程数量为1的线程池，所有提交的这个线程池的任务都会按照提交的先后顺序排队执行</li>
<li>CachedThreadPool：缓存有关的线程池</li>
</ol>
<h3 id="14-如何避免线程死锁？"><a href="#14-如何避免线程死锁？" class="headerlink" title="14.如何避免线程死锁？"></a>14.如何避免线程死锁？</h3><ul>
<li>线程死锁必须满足的四个条件：<ol>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系<br>避免线程死锁最简单的方法就是阻止循环等待条件</li>
</ol>
</li>
</ul>
<h3 id="15-有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#15-有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="15.有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>15.有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h3><ul>
<li>使用线程类种的join（）方法，在一个线程中启动另一个线程，另外一个线程完成该线程继续执行</li>
</ul>
<h3 id="16-Java多线程中调用wait（）和sleep（）方法有什么不同？"><a href="#16-Java多线程中调用wait（）和sleep（）方法有什么不同？" class="headerlink" title="16.Java多线程中调用wait（）和sleep（）方法有什么不同？"></a>16.Java多线程中调用wait（）和sleep（）方法有什么不同？</h3><ul>
<li>Java程序中wait和sleep都会造成某种形式的暂停，他们可以满足不同的需求。<ol>
<li>wait（）方法用于线程间的通信，如果等待条件为真且其他线程被唤醒时它会释放锁</li>
<li>sleep（）方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ytalyq.top/2019/06/02/Linux系统的简单使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清衍之">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyz.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="呼啸山庄的哑舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/02/Linux系统的简单使用/" itemprop="url">Linux系统的简单使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-02T11:24:19+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Linux系统的简单使用"><a href="#Linux系统的简单使用" class="headerlink" title="Linux系统的简单使用"></a>Linux系统的简单使用</h1><ul>
<li>CentOS系统 root yt158851yt   qyz 123456</li>
<li>虚拟机=电脑</li>
<li>快照=备份</li>
<li>创建克隆-创建完整克隆</li>
<li>linux操作系统，适合服务器，不适合办公 稳定 安全性高 免费</li>
</ul>
<h2 id="1-系统路径"><a href="#1-系统路径" class="headerlink" title="1.系统路径"></a>1.系统路径</h2><ul>
<li>/表示根目录</li>
<li>~表示/root</li>
<li>etc 存放系统配置目录</li>
<li>home 除了root以外所有用户默认在home下新建一个以用户名作为文件夹名称的文件夹,(新建一个用户就会在home下新建一个文件夹)</li>
<li>用户xxx对/home/xxx具有完全操作权限，对其他系统文件夹没有操作权限</li>
<li>root 用户的单独文件夹</li>
<li>usr所有用户安装的软件都放在这个文件夹</li>
<li>在/usr/local下新建tmp文件夹，所有压缩包上传到这个文件夹</li>
</ul>
<h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h2><ol>
<li>pwd 打印工作目录，当前所有文件夹的的全路径</li>
<li>cd .. 向上跳一级文件夹</li>
<li>cd 路径 进入指定文件夹    </li>
<li>mkdir 新建空文件夹</li>
<li>ls 平铺</li>
<li>ll 详细列表</li>
<li>vi 编辑文件，vi————&gt;insert/i————&gt;编辑内容————&gt;esc————&gt;:wq(保存并退出)//:q!强制退出</li>
<li>vim 编辑文件(如果文件不存在带有创建文件功能)带有颜色的编辑</li>
<li>touch 创建空文件</li>
<li>cat 查看文件全部内容</li>
<li>head [-n] 文件名 查看文件的前n行，默认前10行</li>
<li>tail [-n] 文件名 查看文件的后n行，默认后10行</li>
<li>tailf 动态显示文件后n行内容 常用在显示tomcat日志文件功能</li>
<li>echo ‘内容’ &gt;&gt; 文件名  向文件中添加一些内容</li>
<li>ifconfig 打印网卡信息</li>
<li>reboot 重启</li>
<li>tar zxvf 文件名</li>
<li>cp <ul>
<li>[-r]原文件 新文件路径    :复制文件</li>
<li>-r 复制文件夹</li>
<li>ctrl+c  中断</li>
<li>mv 原文件  新文件     :剪切(具备重命名的功能)</li>
<li>rm [-rf] 文件名       :删除</li>
<li>-r 删除目录</li>
<li>-f 强制删除，不需要确认</li>
</ul>
</li>
<li>clear 清屏</li>
</ol>
<h2 id="3-linux所有需要写路径的地方都支持两种写法"><a href="#3-linux所有需要写路径的地方都支持两种写法" class="headerlink" title="3.linux所有需要写路径的地方都支持两种写法"></a>3.linux所有需要写路径的地方都支持两种写法</h2><ul>
<li>全路径 以/开头</li>
<li>相对路径 从当前资源一步一步寻找其他资源</li>
</ul>
<h2 id="4-Xshell"><a href="#4-Xshell" class="headerlink" title="4.Xshell"></a>4.Xshell</h2><ul>
<li>linux的客户端工具</li>
<li>CentOS默认只开启22端口，其他端口都被防火墙拦截</li>
</ul>
<h2 id="5-Filezilla工具使用"><a href="#5-Filezilla工具使用" class="headerlink" title="5.Filezilla工具使用"></a>5.Filezilla工具使用</h2><ul>
<li>FTP协议<pre><code>file transfer protocol
</code></pre>  作用：互联网中，计算机之间直接传输文件需要遵循的协议</li>
<li>filezilla<pre><code>基于FTP协议的客户端工具
</code></pre>  使用filezilla可以快速完成文件的传输功能</li>
</ul>
<h2 id="6-安装jdk"><a href="#6-安装jdk" class="headerlink" title="6.安装jdk"></a>6.安装jdk</h2><ul>
<li>把压缩包上传到服务器/usr/local/tmp</li>
<li>解压压缩包<pre><code>#tar zxvf 文件名
</code></pre></li>
<li>把解压后的文件复制到/usr/local/jdk7<pre><code>#cp -r 文件名 /usr/local/jdk7
</code></pre></li>
<li>配置环境变量，执行命令<pre><code>#vim /etc/profile
  修改文件中内容
  (分割使用的是:)
  ($变量名是引用的意思)
  (export 添加或者修改系统变量)
</code></pre>  {<br>  #export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL<pre><code>export JAVA_HOME=/usr/local/jdk7
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
</code></pre>  }</li>
<li>解析文件或重启系统<pre><code>#source /etc/profile
</code></pre></li>
<li>验证配置是否成功<pre><code>#java -version
</code></pre></li>
</ul>
<h2 id="7-Tomcat配置-linux中绿色表示可执行文件"><a href="#7-Tomcat配置-linux中绿色表示可执行文件" class="headerlink" title="7.Tomcat配置(linux中绿色表示可执行文件)"></a>7.Tomcat配置(linux中绿色表示可执行文件)</h2><ul>
<li>把tomcat压缩包上传到服务器</li>
<li>解压tomcat <pre><code>#tar zxvf
</code></pre></li>
<li>解压后的文件夹复制到/usr/local/tomcat7<pre><code>#cp -r apache-tomcat-7.0.94 /usr/local/tomcat7
</code></pre></li>
<li>配置环境变量，执行命令<pre><code>#vim /etc/profile
</code></pre>  修改文件中内容<br>  {<br>  #export TOMCAT_HOME=/usr/local/tomcat7<br>  export CATALINA_HOME=/usr/local/tomcat7<br>  }</li>
<li>放行8080端口<pre><code>#vim /etc/sysconfig/iptables
</code></pre>  把包含22行的内容复制一份改端口为8080(8080:9000 从8080到9000全放行)<br>  重启服务<br>  #service iptables restart (start restart stop)</li>
<li>启动tomcat,进入tomcat7/bin文件夹</li>
<li>直接启动<pre><code>#./startup.sh
</code></pre></li>
<li>启动并动态打印启动信息<pre><code>#./startup.sh &amp; tailf /usr/local/tomcat7/logs/catalina.out
</code></pre></li>
</ul>
<h2 id="8-mysql安装"><a href="#8-mysql安装" class="headerlink" title="8.mysql安装"></a>8.mysql安装</h2><ul>
<li>上传解压</li>
<li>复制到/usr/local/mysql<pre><code>#cp -r mysql-5.6.31 /usr/local/mysql
</code></pre></li>
<li>进入mysql文件夹<pre><code>#cd /usr/local/mysql
</code></pre></li>
<li>添加用户组，命名为mysql<pre><code>#groupadd mysql
</code></pre></li>
<li>创建用户mysql，并指定所属群组mysql<pre><code>#useradd -r -g mysql mysql
</code></pre></li>
<li>变更mysql用户组有操作当前文件夹的权限(必须保证在/usr/local/mysql目录下)<pre><code>#chgrp -R mysql .
</code></pre></li>
<li>变更mysql用户有操作当前文件夹的权限<pre><code>#chown -R mysql .
</code></pre></li>
<li>初始化<pre><code>判断/etc/my.cnf是否存在，存在就删除
      #ls /etc/my.cnf
      #rm /etc/my.cnf    
</code></pre>  初始化数据库<pre><code>#./scripts/mysql_install_db --user=mysql 
</code></pre></li>
<li>修改配置文件<pre><code>- 复制my.cnf
    #cp support-files/my-default.cnf /etc/my.cnf 
</code></pre><ul>
<li>复制启动文件<pre><code>#cp support-files/mysql.server /etc/rc.d/init.d/mysql 
</code></pre></li>
</ul>
</li>
<li>如果提示没有mysql命令，需要添加软连接<pre><code>#ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql 
</code></pre></li>
<li>启动数据库<pre><code>#service mysql start 
</code></pre></li>
<li>操作数据库<pre><code>#mysql -u root -p 
</code></pre></li>
</ul>
<h2 id="9-忘记mysql-root密码的修改方式和修改访问host"><a href="#9-忘记mysql-root密码的修改方式和修改访问host" class="headerlink" title="9.忘记mysql root密码的修改方式和修改访问host"></a>9.忘记mysql root密码的修改方式和修改访问host</h2><ul>
<li>进入/etc/my.cnf在[mysql]下添加skip-grant-tables启动安全模式<pre><code>#vi /etc/my.cnf
</code></pre></li>
<li>重启服务<pre><code>service mysql restart
</code></pre></li>
<li>登录mysql，输入密码时直接回车<pre><code>#mysql -u root -p
</code></pre></li>
<li>进入mysql后，使用mysql数据库<pre><code>#use mysql
</code></pre></li>
<li>修改密码<pre><code>#update user set password= password(&quot;123456&quot;) where user=&apos;root&apos;;
</code></pre></li>
<li>刷新权限<pre><code>#flush privileges;
</code></pre></li>
<li>退出mysql编辑模式<pre><code>#exit
</code></pre></li>
<li>修改访问host<pre><code>#use mysql
</code></pre>  #grant all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;<br>  #flush privileges;<br>  #exit<br>  #vim /etc/sysconfig/iptables</li>
<li>复制22端口为3306<pre><code>#service iptables restart
</code></pre></li>
</ul>
<h2 id="10-导入外部数据库表"><a href="#10-导入外部数据库表" class="headerlink" title="10.导入外部数据库表"></a>10.导入外部数据库表</h2><ul>
<li><p>进入mysql，使用目标数据库</p>
<p>#use demo</p>
<p>#source /usr/local/tmp/demo.sql<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​            </p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ytalyq.top/2019/04/18/MyBatis基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清衍之">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyz.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="呼啸山庄的哑舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/MyBatis基础/" itemprop="url">MyBatis基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T16:33:54+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MyBatis基础"><a href="#MyBatis基础" class="headerlink" title="MyBatis基础"></a>MyBatis基础</h1><h2 id="一：基础知识"><a href="#一：基础知识" class="headerlink" title="一：基础知识"></a>一：基础知识</h2><ul>
<li>对原生态jdbc程序问题总结</li>
<li>mybatis框架原理</li>
<li>mybatis 入门程序</li>
<li>用户的增 删 改 查</li>
<li>mybatis开发dao层的两种方法</li>
<li>原始dao开发方法（程序需要编写dao接口和dao实现类）！<pre><code>mybatis的mapper(相当于dao接口)代理开发方法！
mybatis配置文件SqlMapConfig.xml
mybatis 核心：
mybatis输入映射
mybatis输出映射！
mybatis的动态sql ！
</code></pre></li>
</ul>
<h2 id="二：高级知识"><a href="#二：高级知识" class="headerlink" title="二：高级知识"></a>二：高级知识</h2><ul>
<li><p>订单商品数据模型分析</p>
</li>
<li><p>高级结果映射(一对一、一对多、多对多)</p>
</li>
<li><p>mybatis延时加载</p>
</li>
<li><p>mybatis查询缓存(一级缓存、二级缓存)</p>
</li>
<li><p>mybatis和Spring进行整合！</p>
</li>
<li><p>mybatis逆向工程</p>
</li>
<li><p>为什么使用mybatis?</p>
<ul>
<li><p>解决JDBC存在的问题和简化数据库操作，mybatis提供了较好的解决方案</p>
</li>
<li><p>例如：</p>
<ol>
<li>可以通过主配置文件配置连接池频繁创建、释放数据库连接造成的性能影响</li>
<li>动态sql解决JDBC中硬编码问题<pre><code>a.Where条件改变
</code></pre>   b.占位符位置变化</li>
<li>可以通过包装类方便的获取数据库查询结果集对象</li>
<li>使dao层业务逻辑和数据库访问分离更易维护和测试</li>
</ol>
</li>
<li><p>学习路径：</p>
<ol>
<li><p>了解mybatis架构</p>
</li>
<li><p>掌握mybatis框架搭建、配置</p>
</li>
<li><p>使用mybatis 完成对数据库的增、删、改、查操作</p>
</li>
<li><p>掌握Mapper代理开发</p>
</li>
<li><p>掌握动态SQL编写SQL语句</p>
</li>
<li><p>掌握输入与输出映射</p>
</li>
<li><p>掌握多表关联查询    </p>
</li>
<li><p>搭建MyBatis项目</p>
<pre><code>(1)下载mybatis 、创建项目、导包
</code></pre><p>(2)创建测试用例，测试数据库，测试bean对象<br>(3)创建sqlMapperconfig.xml主配置文件</p>
<pre><code>a.导入主配置文件头
</code></pre></li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br></pre></td></tr></table></figure>

​    (4)创建Mapper.xml映射文件

​        a.导入Mapper文件头

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">	&lt;!DOCTYPE mapper</span><br><span class="line">	PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">	<span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br></pre></td></tr></table></figure>

​    (5)导入约束

​    (6)创建MyBatis SqlSessionFactory 的几种方式

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置文件的名称	主配置文件</span></span><br><span class="line">   String resource = <span class="string">"ssm/configuration.xml"</span>;</span><br><span class="line">   <span class="comment">//通过Mybatis包中的Resources对象获取到配置文件</span></span><br><span class="line">   Reader reader = Resources.getResourceAsReader(resource);</span><br><span class="line">   <span class="comment">//通过SqlSessionFactoryBuilder创建</span></span><br><span class="line">   SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">   <span class="comment">//获得session实例</span></span><br><span class="line">   SqlSession session =sqlSessionFactory.openSession();</span><br><span class="line">   User user = <span class="keyword">new</span> User();</span><br><span class="line">   user.setId(<span class="number">8</span>);</span><br><span class="line">   <span class="comment">//完成数据库的插入</span></span><br><span class="line">   session.insert(<span class="string">"add"</span>, user);</span><br><span class="line">   session.commit();</span><br><span class="line">   session.close();</span><br><span class="line">   System.out.println(sqlSessionFactory);</span><br><span class="line"></span><br><span class="line">通过Mapper动态代理的方式	用来替代Dao层</span><br><span class="line">String resource = <span class="string">"sqlMapConfig.xml"</span>;</span><br><span class="line">Reader rd = Resources.getResourceAsReader(resource);</span><br><span class="line">SqlSessionFactory ssf = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(rd);</span><br><span class="line">SqlSession session = ssf.openSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">mapper.deleteUserById();</span><br><span class="line">mapper.selectALT+/;</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">mapper.updateUser(user);</span><br><span class="line">session.commit();</span><br><span class="line"> * Mapper动态代理四个原则</span><br><span class="line"> * <span class="number">1</span>.接口方法名需要与Mapper.xml中要调用的SQL语句ID一致 </span><br><span class="line"> * <span class="number">2</span>.接口的形参类型需要与Mapper.xml中的 ParameterType一致	</span><br><span class="line"> * <span class="number">3</span>.接口的返回值类型需要与Mapper.xml中的返回值类型一致</span><br><span class="line"> * <span class="number">4</span>.Mapper.xml中的NameSpace与接口的全包名一致</span><br><span class="line"> * <span class="number">5</span>.注意事项：Mapper动态代理开发中，select类型根据返回值类型自动选择</span><br></pre></td></tr></table></figure>

​    (7)使用MyBatis对表进行增、删、改、查操作

​        在mapper.xml映射文件中配置，SQL语句
​        a.通过id查询一个用户        #{id}    占位符    传递过来的参数
​        b.通过用户名模糊查找匹配的用户列表        ${value}字符串拼接//不建议    &quot;%&quot;#{name}&quot;%&quot;
​        c.完成用户添加    insert into table values(${},....传递的参数)
​        d.修改用户        update table set colname = ${传递的参数} where id = #{传递的参数}
​        e.根据id删除用户        delete * from table where id = ${id}

​    (8)MyBatis主配置文件sqlMapConfig.xml说明注意事项：

​        主配置文件按照以下顺序读取配置，顺序不对报错
​        1.properties（读取配置文件） 用来连接数据库 需要建一个properties文件！
​        2.settings（全局配置参数）
​        3.typeAliases(类型别名)用来给mapper.xml文件中返回值的完整包名起一个缩写的别名！
​        &lt;typeAliases&gt;
​        &lt;typeAlias type=&quot;com.yt.bean.User&quot; alias=&quot;User&quot;/&gt;
​        &lt;/typeAliases&gt;
​        4.typeHandlers(类型处理器)
​        5.objectFactory(对象工厂)
​        6.plugins(插件)
​        7.environments(环境集合属性对象    Spring框架整合后不需要)
​        8.mappers (配置映射器位置)推荐包的形式,mapper.xml文件应与 Mapper接口名字一样且在一个包下！

​    (9)MaBatis输入输出映射

​        1.输入映射parameterType
​        基本类型    自定义对象    自定义包装类
​        2.输出映射resultType resultMap
​        a)resultType：基本类型    自定义对象    集合
​        b)resultMap: 如果bean对象字段与数据库表字段不匹配使用之手动映射
​        举例：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=<span class="string">"Role"</span> id=<span class="string">"role"</span>&gt;</span><br><span class="line">	&lt;result property=<span class="string">"id"</span> column=<span class="string">"idroles"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/resultMap&gt;</span></span><br><span class="line"><span class="regexp">&lt;select id="selectAll" resultMap="role"&gt;</span></span><br><span class="line"><span class="regexp">	select * from roles </span></span><br><span class="line"><span class="regexp">&lt;/</span>select&gt;</span><br></pre></td></tr></table></figure>

​        自定义包装类    关联查询

​    (10)关联查询

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">左关联：</span><br><span class="line">	SELECT </span><br><span class="line">	u.id,u.username,u.sex,r.idroles,r.rolename &lt;!-- 要查找的属性--!&gt;</span><br><span class="line">	FROM users u 							   &lt;!-- 来自那个表--!&gt;</span><br><span class="line">	LEFT JOIN roles r 						   &lt;!-- 关联那个表--!&gt;</span><br><span class="line">	ON u.id=r.idroles						   &lt;!-- 关联的字段主键 --!&gt;</span><br><span class="line">	一对多查询</span><br><span class="line">	SELECT </span><br><span class="line">	u.id,u.username,u.sex,r.idroles,r.rolename &lt;!-- 要查找的属性--!&gt;</span><br><span class="line">	FROM users u 							   &lt;!-- 来自一的表--!&gt;</span><br><span class="line">	LEFT JOIN roles r 						   &lt;!-- 关联多的表--!&gt;</span><br><span class="line">	ON u.id=r.idroles						   &lt;!-- 关联的字段主键 --!&gt;</span><br></pre></td></tr></table></figure>

​    (11).MyBatis动态sql：方便拼接sq语句

​            1.if标签 -多条件查询、获取用户列表
​            &lt;if test=&quot;sex!=null&quot;&gt;
​                sex =#{sex}
​            &lt;/if&gt;
​            2.where标签
​            3.trim标签
​            4.set标签
​            5.foreach标签
​            6.sql标签

​            
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ytalyq.top/2019/04/18/first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清衍之">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyz.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="呼啸山庄的哑舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/first/" itemprop="url">first</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T15:54:25+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一次            </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/qyz.jpg" alt="清衍之">
            
              <p class="site-author-name" itemprop="name">清衍之</p>
              <p class="site-description motion-element" itemprop="description">Wuthering Heights Dumb house</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">清衍之</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":800},"mobile":{"show":true},"log":false});</script></body>
</html>
